/*
 *    Constellation - An open source and standard compliant SDI
 *    http://www.constellation-sdi.org
 *
 * Copyright 2014 Geomatys.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.constellation.json.metadata;

import java.util.Arrays;


/**
 * A path together with an index for each component in the path.
 * This is used as keys for storing metadata values in a map.
 *
 * <p><b>Implementation note:</b>
 * We store the full path, not only the last UML identifier, because the same metadata object could be reached
 * by different paths (e.g. {@code "contact.party"} and {@code "identificationInfo.pointOfContact.party"}).</p>
 *
 * @author Martin Desruisseaux (Geomatys)
 */
final class NumerotedPath {
    /**
     * The path where to fetch the value. Array content must not be changed,
     * since this is the same reference than {@link TemplateNode#path}.
     */
    private final String[] path;

    /**
     * The index of each elements in the path. The length of this array is smaller than
     * or equals to {@code path.length}.
     */
    private final int[] indices;

    /**
     * Creates a new key for the given path and indices.
     *
     * @param path    The path, stored by reference (the array is not and should not be cloned).
     * @param indices The index of each elements in the path. This array will be partially copied.
     * @param depth   Number of valid elements in the path.
     */
    NumerotedPath(final String[] path, final int[] indices, final int depth) {
        this.path    = path; // No copy.
        this.indices = Arrays.copyOfRange(indices, 0, depth);
    }

    /**
     * Returns a hash code value for this key.
     */
    @Override
    public int hashCode() {
        return Arrays.hashCode(path) ^ Arrays.hashCode(indices);
    }

    /**
     * Returns {@code true} if the given key is equals to the given object.
     */
    @Override
    public boolean equals(final Object other) {
        return (other instanceof NumerotedPath) &&
               Arrays.equals(path,    ((NumerotedPath) other).path) &&
               Arrays.equals(indices, ((NumerotedPath) other).indices);
    }

    /**
     * Returns a string representation for debugging purpose.
     */
    @Override
    public String toString() {
        final StringBuilder buffer = new StringBuilder();
        for (int i=0; i<path.length; i++) {
            if (i != 0) {
                buffer.append('.');
            }
            buffer.append(path[i]);
            if (i < indices.length) {
                buffer.append('[').append(indices[i]).append(']');
            }
        }
        return buffer.toString();
    }
}
