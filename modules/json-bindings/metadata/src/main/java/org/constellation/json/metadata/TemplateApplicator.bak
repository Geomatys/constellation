/**
 * Note: elements already present in TemplateApplication.java have been removed from this file.
 */
final class TemplateApplicator {
    /**
     * Value stored in the {@link #remainingValues} map after we used all metadata values for a given path.
     */
    private static final ValueNode[] EMPTY = new ValueNode[0];

    /**
     * If a metadata values has been requested, the remaining values after we processed the values for
     * the current node. This is used for avoiding to write the same values many time if the same path
     * appears more than once.
     */
    private final Map<NumerotedPath,ValueNode[]> remainingValues;

    /**
     * Given a newly computed set of {@link #nodes}, separates the value to use for the given {@code TemplateNode}.
     * Remaining values (which are often an empty array) will be stored in the {@link #remainingValues} map.
     *
     * <p>The current version only ensures that the number of elements is not greater than {@link TemplateNode#maxOccurs}.
     * However if we want to apply a more sophisticated filter in a future version, it could be applied here.</p>
     *
     * @param path The key to use for storing the remaining values in the map, or {@code null} if none.
     */
    private void filterNewValues(final NumerotedPath path) {
        final int size      = nodes.size();
        final int maxOccurs = path.template.maxOccurs;
        final ValueNode[] remaining;
        if (size <= maxOccurs) {
            remaining = EMPTY; // This is the most common case.
        } else {
            final List<ValueNode> subList = nodes.subList(maxOccurs, size);
            remaining = subList.toArray(new ValueNode[subList.size()]);
            subList.clear();
        }
        if (remainingValues.put(path, remaining) != null) {
            throw new ConcurrentModificationException();
        }
    }

    /**
     * Given a path which is used for the second time or more, returns as many values as we can use
     * and removes the used values from the {@link #remainingValues} map.
     *
     * @param  path   The key which has been used for storing {@code remaining} in the {@link #remainingValues} map.
     * @param  values The value of {@code remainingValues.get(path)}.
     * @return The values to write for the current {@code TemplateNode}.
     */
    private ValueNode[] filterExistingValues(final NumerotedPath path, final ValueNode[] values) {
        final int maxOccurs = path.template.maxOccurs;
        final ValueNode[] filtered, remaining;
        if (maxOccurs < values.length) {
            filtered  = Arrays.copyOfRange(values, 0, maxOccurs);
            remaining = Arrays.copyOfRange(values, maxOccurs, values.length);
        } else {
            filtered = values;
            remaining = EMPTY;
        }
        if (remainingValues.put(path, remaining) != values) {
            throw new ConcurrentModificationException();
        }
        return filtered;
    }
}
