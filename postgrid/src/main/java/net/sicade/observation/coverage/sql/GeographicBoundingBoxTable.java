/*
 * Sicade - Systèmes intégrés de connaissances pour l'aide à la décision en environnement
 * (C) 2006, Institut de Recherche pour le Développement
 *
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 2.1 of the License, or (at your option) any later version.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 */
package net.sicade.observation.coverage.sql;

// J2SE dependencies
import java.awt.Dimension;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.PreparedStatement;
import java.util.logging.Level;
import java.util.logging.LogRecord;

// Seagis
import net.sicade.observation.Element;
import net.sicade.observation.CatalogException;
import net.sicade.observation.SpatialConfigurationKey;
import net.sicade.observation.sql.Table;
import net.sicade.observation.sql.Database;
import net.sicade.observation.sql.Shareable;
import net.sicade.resources.i18n.Resources;
import net.sicade.resources.i18n.ResourceKeys;

// OpenGIS dependencies
import org.opengis.metadata.extent.GeographicBoundingBox;

// PostGIS Dependencies
import org.postgis.PGbox3d;
import org.postgis.Point;


/**
 * Connexion à la table des étendues géographiques des images.
 *
 * @version $Id$
 * @author Martin Desruisseaux
 * @author Antoine Hnawia
 */
public class GeographicBoundingBoxTable extends Table implements Shareable {
    /**
     * Facteur de tolérance pour la comparaison des limites géographiques.
     */
    private static final double EPSILON = 1E-7;

    /**
     * The SQL instruction to use when looking for bounding box. Note that an "INSERT"
     * instruction may be generated by the {@link #addGeographicBoundingBox} method.
     */
    private static final SpatialConfigurationKey SELECT = new SpatialConfigurationKey("GeographicBoundingBoxes:SELECT",
            "SELECT id FROM \"GridGeometries\"\n"        +
            " WHERE ABS(\"westBoundLongitude\" - ?) <= " + EPSILON  + '\n' +
            "   AND ABS(\"eastBoundLongitude\" - ?) <= " + EPSILON  + '\n' +
            "   AND ABS(\"southBoundLatitude\" - ?) <= " + EPSILON  + '\n' +
            "   AND ABS(\"northBoundLatitude\" - ?) <= " + EPSILON  + '\n' +
            "   AND ABS(\"altitudeMin\" - ?)        <= " + EPSILON  + '\n' +
            "   AND ABS(\"altitudeMax\" - ?)        <= " + EPSILON  + '\n' +
            "   AND width=? AND height=? AND depth=?",

            // TODO: take epsilon in account
            "SELECT id FROM \"GridGeometries\"\n"       +
            " WHERE \"spatialExtent\" = ?\n"            +
            "   AND width=? AND height=? AND depth=?");

    /**
     * The SQL instruction for inserting a new geographic bounding box.
     *
     * @todo Choose the CRS.
     */
    private static final SpatialConfigurationKey INSERT = new SpatialConfigurationKey("GeographicBoundingBoxes:INSERT",
            "INSERT INTO \"GridGeometries\"\n" +
            "  (id, \"westBoundLongitude\",\n" +
            "       \"eastBoundLongitude\",\n" +
            "       \"southBoundLatitude\",\n" +
            "       \"northBoundLatitude\",\n" +
            "       \"altitudeMin\",\n"        +
            "       \"altitudeMax\",\n"        +
            "       \"CRS\",\n"                +
            "       width, height, depth)\n"   +
            "  VALUES (?, ?, ?, ?, ?, ?, ?, 'IRD:WGS84(xyt)', ?, ?, ?)",

            "INSERT INTO coverages.\"GridGeometries\"\n"+
            "  (id, \"spatialExtent\",\n"               +
            "       \"CRS\",\n"                         +
            "       width, height, depth)\n"            +
            "  VALUES (?, ?, 'IRD:WGS84(xyt)', ?, ?, ?)");

    /**
     * Constructs a new {@code GeographicBoundingBoxTable}.
     *
     * @param  connection The connection to the database.
     * @throws SQLException if the table can't be constructed.
     */
    public GeographicBoundingBoxTable(final Database database) throws SQLException {
        super(database);
    }

    /**
     * Retourne l'identifieur de l'étendue géographique et la dimension d'image spécifiées.
     * Si aucun enregistrement n'a été trouvée, alors cette méthode retourne {@code null}.
     *
     * @param  bbox The geographic bounding box.
     * @param  size The image size, in pixels.
     * @throws SQLException if the operation failed.
     */
    public synchronized String getIdentifier(final GeographicBoundingBox bbox, final Dimension size)
            throws SQLException
    {
        final PreparedStatement statement = getStatement(getProperty(SELECT));
        setBoundingBox(statement, 0, bbox, size);
        String ID = null;
        final ResultSet result = statement.executeQuery();
        while (result.next()) {
            final String nextID = result.getString(1);
            if (ID!=null && !ID.equals(nextID)) {
                final LogRecord record = Resources.getResources(database.getLocale()).
                        getLogRecord(Level.WARNING, ResourceKeys.ERROR_DUPLICATED_GEOMETRY_$1, nextID);
                record.setSourceClassName("GeographicBoundingBoxTable");
                record.setSourceMethodName("getIdentifier");
                Element.LOGGER.log(record);
            } else {
                ID = nextID;
            }
        }
        result.close();
        return ID;
    }

    /**
     * Ajoute une entrée pour l'étendue géographique et la dimension d'image spécifiée.
     */
    public synchronized void addEntry(final String          identifier,
                                      final GeographicBoundingBox bbox,
                                      final Dimension             size)
            throws CatalogException, SQLException
    {
        final PreparedStatement statement = getStatement(getProperty(INSERT));
        statement.setString(1, identifier);
        setBoundingBox(statement, 1, bbox, size);
        if (statement.executeUpdate() != 1) {
            throw new CatalogException("L'étendue géographique n'a pas été ajoutée.");
        }
    }

    /**
     * Set the bounding box for the specified statement.
     *
     * @param statement The statement on which to set the parameters.
     * @param parameter The first parameter (minus one) to set.
     * @param bbox      The bounding box to fetch values from.
     * @param size      The image size to search for.
     */
    private void setBoundingBox(final PreparedStatement statement, int parameter,
                                final GeographicBoundingBox bbox, final Dimension size)
            throws SQLException
    {
        if (database.isSpatialEnabled()) {
            statement.setObject(++parameter, createBBOX3D(bbox));
        } else {
            statement.setDouble(++parameter, bbox.getWestBoundLongitude());
            statement.setDouble(++parameter, bbox.getEastBoundLongitude());
            statement.setDouble(++parameter, bbox.getSouthBoundLatitude());
            statement.setDouble(++parameter, bbox.getNorthBoundLatitude());
            statement.setDouble(++parameter, 0.0); // TODO
            statement.setDouble(++parameter, 0.0); // TODO
        }
        statement.setInt(++parameter, size.width);
        statement.setInt(++parameter, size.height);
        statement.setInt(++parameter, 1); // TODO
    }

    /**
     * Creates the {@code BBOX3D} elements.
     *
     * @todo Current implementation is PostGIS specific.
     * @todo Altitude is currently ignored.
     */
    private static Object createBBOX3D(final GeographicBoundingBox bbox) {
        return new PGbox3d(
                new Point(bbox.getWestBoundLongitude(), bbox.getEastBoundLongitude(), 0.0),
                new Point(bbox.getSouthBoundLatitude(), bbox.getNorthBoundLatitude(), 0.0));
    }
}
