/*
 * (C) 2008, Geomatys
 *
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 2.1 of the License, or (at your option) any later version.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with this library; if not, write to the Free Software
 *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package net.seagis.console;

import java.awt.Point;
import java.awt.Dimension;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.sql.SQLException;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Properties;
import java.util.SortedSet;
import java.util.StringTokenizer;
import java.util.logging.Level;
import javax.imageio.ImageWriteParam;
import javax.imageio.spi.ImageReaderSpi;
import javax.imageio.spi.ImageWriterSpi;

import org.geotools.geometry.Envelope2D;
import org.geotools.image.io.mosaic.Tile;
import org.geotools.image.io.mosaic.TileManager;
import org.geotools.image.io.mosaic.MosaicBuilder;
import org.geotools.image.io.mosaic.TileManagerFactory;
import org.geotools.util.FrequencySortedSet;
import org.geotools.resources.Arguments;
import org.geotools.resources.image.ImageUtilities;

import net.seagis.catalog.Database;
import net.seagis.catalog.CatalogException;
import net.seagis.coverage.catalog.WritableGridCoverageTable;


/**
 * Creates tiles and write the entries in the database.
 *
 * @author Cédric Briançon
 * @author Martin Desruisseaux
  */
public class TileBuilder {
    /**
     * Properties read from the file specified on the command line. After the extraction
     * of configuration options like the {@linkplain #sourceDirectory source directory},
     * {@linkplain #tileSize tile size}, <cite>etc.</cite>, it should contains only the
     * list of source tiles to process.
     */
    private Properties properties;

    /**
     * Directory extracted from the {@linkplain #properties}. The source directory contains
     * the tiles of an existing mosaic, typically as very big tiles. The target directory is
     * the place where to write the tiles generated by this class.
     */
    protected File sourceDirectory, targetDirectory;

    /**
     * The geographic envelope, or {@code null} if unspecified.
     */
    private Envelope2D envelope;

    /**
     * The target tile size, or {@code null} if unspecified.
     */
    private Dimension tileSize;

    /**
     * The format of the tile to be written, or {@code null} if unspecified.
     */
    private String format;

    /**
     * The series for the tiles to be inserted in the database.
     */
    private String series;

    /**
     * Flags specified on the command lines.
     */
    private boolean keepLayout, noCompress, writeToDisk, fillDatabase, pretend;

    /**
     * Standard output streams.
     */
    protected PrintWriter out, err;

    /**
     * Disables JAI codecs. Experience shows that the coded bundled in J2SE work better.
     */
    static {
        ImageUtilities.allowNativeCodec("PNG", ImageReaderSpi.class, false);
        ImageUtilities.allowNativeCodec("PNG", ImageWriterSpi.class, false);
    }

    /**
     * Creates a new builder and run immediately (and only once). This constructor invokes
     * the following methods:
     * <p>
     * <ul>
     *   <li>{@link #parseArguments}</li>
     *   <li>{@link #createSourceTiles}</li>
     * </ul>
     * <p>
     * Those methods can be overriden by subclasses. In case of failure, a message is printed to
     * the {@link System#err standard error stream} and this constructor finishs without throwing
     * exception.
     * <p>
     * Instances of {@code TileBuilder} can be used only once. Their work are finished immediately
     * after construction.
     *
     * @param args The command line arguments.
     */
    protected TileBuilder(final String[] args) {
        final Arguments arguments = new Arguments(args);
        out = arguments.out;
        err = arguments.err;
        if (parseArguments(arguments)) {
            final Collection<Tile> tiles = createSourceTiles();
            if (tiles != null) {
                if (tiles.isEmpty()) {
                    err.println("At least one tile must be specified.");
                } else {
                    createTargetTiles(tiles);
                }
            }
        }
        out.flush();
    }

    /**
     * Parses the given command line arguments. If a subclass overrides this method,
     * then it must invoke {@code super.parseArguments(arguments)} at some point.
     *
     * @param  arguments The command line arguments.
     * @return {@code true} on success, or {@code false} on failure. In the later case,
     *         a message is printed to the {@link System#err standard error stream}.
     */
    protected boolean parseArguments(final Arguments arguments) {
        keepLayout   = arguments.getFlag("--keep-layout");
        noCompress   = arguments.getFlag("--no-compress");
        writeToDisk  = arguments.getFlag("--write-to-disk");
        fillDatabase = arguments.getFlag("--fill-database");
        pretend      = arguments.getFlag("--pretend");
        final String[] args = arguments.getRemainingArguments(1);
        if (args.length != 1) {
            err.println("Missing argument: properties file");
            return false;
        }
        /*
         * Reads the property file and parses some of its value into File, Envelope
         * or Dimension objects. Failure to parse will stop the method immediately.
         */
        properties = new Properties();
        try {
            final InputStream in = new FileInputStream(args[0]);
            properties.load(in);
            in.close();
        } catch (IOException e) {
            err.println(e);
            return false;
        }
        try {
            sourceDirectory = getDirectory("SourceDirectory");
            targetDirectory = getDirectory("TargetDirectory");
            envelope        = getEnvelope ("MosaicEnvelope" );
            tileSize        = getDimension("TileSize"       );
        } catch (NumberFormatException e) {
            err.println(e);
            return false;
        } catch (IllegalArgumentException e) {
            err.println(e);
            return false;
        }
        format = (String) properties.remove("Format");
        series = (String) properties.remove("Series");
        return true;
    }

    /**
     * Creates the collection of source tiles. The default implementation builds the collection from
     * the files declared in the property file given on the command line. Subclass can override this
     * method in order to complete the collection in an other way.
     *
     * @return A collection (maybe empty) on success, or {@code null} on failure. In the later
     *         case, a message is printed to the {@link System#err standard error stream}.
     */
    protected Collection<Tile> createSourceTiles() {
        Collection<Tile> tiles = new HashSet<Tile>();
        for (final Map.Entry<?,?> entry : properties.entrySet()) {
            final String file  = (String) entry.getKey();
            final String value = (String) entry.getValue();
            final Point origin;
            try {
                origin = parsePoint(value);
            } catch (RuntimeException e) {
                err.println(e);
                return null;
            }
            final Tile tile = new Tile(null, new File(sourceDirectory, file), 0, origin, null);
            tiles.add(tile);
        }
        return tiles;
    }

    /**
     * Creates the target tiles, optionnaly writes them to disk and to the database.
     */
    private boolean createTargetTiles(Collection<Tile> tiles) {
        if (!targetDirectory.isDirectory()) {
            err.print(targetDirectory.getPath());
            err.println(" is not a directory.");
            return false;
        }
        /*
         * From the big tiles declared in the property files, infers a set of smaller tiles at
         * different overview levels. For example starting with 6 BlueMarble tiles, we can get
         * 4733 tiles of size 960 x 960 pixels. The result is printed to the standard output.
         */
        MosaicBuilder builder = new MosaicBuilder() {
            @Override
            protected void onTileWrite(Tile tile, ImageWriteParam parameters) throws IOException {
                if (noCompress) {
                    parameters.setCompressionMode(ImageWriteParam.MODE_DISABLED);
                }
            }
        };
        builder.setLogLevel(Level.INFO);
        if (tileSize != null) {
            builder.setTileSize(tileSize);
        }
        builder.setTileDirectory(targetDirectory);
        builder.setMosaicEnvelope(envelope);
        builder.setTileReaderSpi(format);
        final TileManager tileManager;
        if (keepLayout) {
            tileManager = TileManagerFactory.DEFAULT.create(tiles)[0];
        } else try {
            tileManager = builder.createTileManager(tiles, 0, writeToDisk && !pretend);
        } catch (IOException e) {
            err.println(e);
            return false;
        }
        tiles = tileManager.getTiles();
        /*
         * Creates a global tiles which cover the whole area.
         * We will use the most frequently used file suffix for this tile.
         *
         * TODO: probably a bad idea - WritableGridCoverageTable will no accepts arbitrary suffix,
         *       but only the suffix expected by the series. We will need to revisit this policy.
         */
        final SortedSet<String> suffixes = new FrequencySortedSet<String>(true);
        for (final Tile tile : tiles) {
            final Object input = tile.getInput();
            if (input instanceof File) {
                final String file = ((File) input).getName();
                final int split = file.lastIndexOf('.');
                if (split >= 0) {
                    suffixes.add(file.substring(split));
                }
            }
        }
        String name = series;
        if (!suffixes.isEmpty()) {
            name += suffixes.first();
        }
        final Tile global;
        try {
            global = tileManager.createGlobalTile(null, name, 0);
        } catch (IOException e) {
            err.println(e);
            return false;
        }
        /*
         * Fills the database if requested by the user. The tiles entries will be inserted in the
         * "Tiles" table while the global entry will be inserted into the "GridCoverages" table.
         */
        out.println(tileManager);
        if (fillDatabase) try {
            final Database database = new Database();
            if (pretend) {
                database.setUpdateSimulator(out);
            }
            final WritableGridCoverageTable table = new WritableGridCoverageTable(
                    database.getTable(WritableGridCoverageTable.class));
            table.setCanInsertNewLayers(true);
            table.setLayer(series);
            table.addEntry(global);
            table.addTiles(tiles);
            database.close();
        } catch (IOException e) {
            err.println(e);
            return false;
        } catch (SQLException e) {
            err.println(e);
            return false;
        } catch (CatalogException e) {
            err.println(e);
            e.printStackTrace();
            return false;
        }
        out.flush();
        return true;
    }

    /**
     * Returns a directory from the set of properties, or {@code null} if none.
     * The key will be <strong>removed</strong> from the set of properties.
     *
     * @param  key The key to read in the properties.
     * @return The directory, or {@code null} if none.
     */
    private File getDirectory(final String key) {
        final String value = (String) properties.remove(key);
        if (value == null) {
            return null;
        }
        return new File(value);
    }

    /**
     * Parses a text as a point in pixel coordinates.
     *
     * @param  text The text to parse.
     * @return The point, or {@code null} if none.
     * @throws NumberFormatException if a number can't be parsed.
     * @throws IllegalArgumentException If the point doesn't have the expected dimension.
     */
    private Point parsePoint(final String text) throws NumberFormatException, IllegalArgumentException {
        if (text == null) {
            return null;
        }
        int i = 0;
        final Point point = new Point();
        final StringTokenizer tokens = new StringTokenizer(text);
        while (tokens.hasMoreTokens()) {
            final int value = Integer.parseInt(tokens.nextToken());
            switch (i++) {
                case 0:  point.x = value; break;
                case 1:  point.y = value; break;
                default: break; // An exception will be thrown at the end of this method.
            }
        }
        if (i != 2) {
            throw new IllegalArgumentException("Expected 2 values but found \"" + text + '"');
        }
        return point;
    }

    /**
     * Parses a text from the properties as a dimension in pixel coordinates.
     * The key will be <strong>removed</strong> from the set of properties.
     *
     * @param  key The key to read in the properties.
     * @return The dimension, or {@code null} if none.
     * @throws NumberFormatException if a number can't be parsed.
     * @throws IllegalArgumentException If the point doesn't have the expected dimension.
     */
    private Dimension getDimension(final String key) throws NumberFormatException, IllegalArgumentException {
        final String text = (String) properties.remove(key);
        final Point point = parsePoint(text);
        if (point != null) {
            return new Dimension(point.x, point.y);
        }
        return null;
    }

    /**
     * Parses a text from the properties as an envelope in "real world" coordinates.
     * The key will be <strong>removed</strong> from the set of properties.
     *
     * @param  key The key to read in the properties.
     * @return The envelope, or {@code null} if none.
     * @throws NumberFormatException if a number can't be parsed.
     * @throws IllegalArgumentException If the envelope doesn't have the expected dimension.
     */
    private Envelope2D getEnvelope(final String key) throws IllegalArgumentException, NumberFormatException {
        final String text = (String) properties.remove(key);
        if (text == null) {
            return null;
        }
        int i = 0;
        final Envelope2D envelope = new Envelope2D();
        final StringTokenizer tokens = new StringTokenizer(text);
        while (tokens.hasMoreTokens()) {
            final double value = Double.parseDouble(tokens.nextToken());
            switch (i++) {
                case 0:  envelope.x = value; break;
                case 1:  envelope.y = value; break;
                case 2:  envelope.width  = value - envelope.x; break;
                case 3:  envelope.height = value - envelope.y; break;
                default: break; // An exception will be thrown at the end of this method.
            }
        }
        if (i != 4) {
            throw new IllegalArgumentException("Expected 4 values but found \"" + text + '"');
        }
        return envelope;
    }

    /**
     * Runs from the command line.
     */
    public static void main(String[] args) {
        final TileBuilder builder = new TileBuilder(args);
        // Done, everything was executed in constructor.
    }
}
